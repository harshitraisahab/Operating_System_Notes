### **Non-Contiguous Memory Allocation:**
In **non-contiguous memory allocation**, a process’s memory is divided into small, fixed-size blocks, which can be scattered throughout physical memory. The OS maps these scattered blocks to the process’s logical address space. This contrasts with **contiguous allocation**, where a process is allocated a single, continuous block of memory.

#### **Advantages:**
1. **Efficient Memory Use:** Allows a process to fit into available memory even if it’s not continuous, thus utilizing memory more efficiently.
2. **No External Fragmentation:** Because processes are broken into smaller chunks, they can be placed in any available blocks, reducing external fragmentation.

#### **Disadvantages:**
1. **Overhead:** Requires complex address translation, which involves managing tables like the **page table**.
2. **Performance Hit:** Accessing memory becomes slower due to the need for address translation.

---

### **Paging:**
**Paging** is a memory management scheme that eliminates the need for contiguous memory allocation by dividing physical memory into fixed-size blocks called **frames** and dividing processes into equally sized blocks called **pages**.

#### **Key Components of Paging:**
1. **Pages:** Fixed-size blocks in a process’s logical memory.
2. **Frames:** Fixed-size blocks in physical memory.
3. **Page Table:** A data structure used by the OS to keep track of the mapping between pages and frames.

When a process is executed, its pages are loaded into available frames in physical memory. The OS uses the **page table** to translate logical addresses to physical addresses.

#### **Example:**
   - Assume a process has 4 pages, and physical memory has 5 frames.
   - Pages of the process are mapped to frames as follows:
     - Page 0 → Frame 3
     - Page 1 → Frame 0
     - Page 2 → Frame 4
     - Page 3 → Frame 2
     
The OS maintains a **page table** to manage this mapping, allowing the process to be scattered across memory without needing contiguous space.

---

### **Frames:**
- **Frames** are fixed-size blocks of physical memory. The size of a frame is the same as the size of a page.
  
- **Example:** If a system’s memory is divided into 4 KB frames, and a process is 16 KB in size, it will be divided into 4 pages, each of 4 KB. Each page is then placed into one of the available frames.

---

### **Logical Address and Physical Address:**
1. **Logical Address (Virtual Address):**
   - The address generated by the CPU when a process accesses memory.
   - This address is **virtual** because the OS translates it into a physical address using the page table.

2. **Physical Address:**
   - The actual address in physical memory (RAM) where data resides.
   - The OS converts logical addresses into physical addresses through the page table during memory access.

---

### **Address Translation in Paging:**
1. **Logical Address:** Consists of two parts:
   - **Page Number (p):** Identifies the page in the logical address space.
   - **Offset (d):** Identifies the specific location within the page.
   
   Example: Logical address = **p + d**

2. **Physical Address:** Also consists of two parts:
   - **Frame Number (f):** Identifies the frame in physical memory.
   - **Offset (d):** Same as the offset in the logical address.
   
   Example: Physical address = **f + d**

#### **Example of Address Translation:**
   - Assume the system has a page size of 4 KB (4096 bytes), and the logical address space is 32 KB. 
   - A process generates a logical address: **13,052**.
     - Page number (p) = 13052 / 4096 = 3 (quotient)
     - Offset (d) = 13052 % 4096 = 764 (remainder)
   - The page table shows that page 3 is mapped to frame 5.
     - So, the physical address is frame 5 with offset 764.

---

### **Page Table:**
The **page table** is a data structure maintained by the OS to map **logical addresses** to **physical addresses**. Each process has its own page table.

#### **Structure:**
- **Page Number:** Index into the page table that corresponds to the logical page in the process.
- **Frame Number:** The frame in physical memory where the page is stored.

#### **Example:**
| **Page Number** | **Frame Number** |
|-----------------|------------------|
| 0               | 2                |
| 1               | 7                |
| 2               | 5                |
| 3               | 1                |

If a process needs to access logical address **13,052**, the OS first identifies the page number (3) and then looks up the corresponding frame number (1). It adds the offset to the frame number to form the physical address.

---

### **Example of Paging in Action:**
Let’s say we have a system with:
- **Physical memory size** = 32 KB
- **Page size** = 4 KB
- **Logical memory size** = 16 KB
- A process of 16 KB will have 4 pages:
  - Page 0, Page 1, Page 2, Page 3

The physical memory is divided into 8 frames of 4 KB each:
- Frame 0, Frame 1, Frame 2, …, Frame 7

Assume the pages of the process are stored in the following frames:
- Page 0 → Frame 5
- Page 1 → Frame 3
- Page 2 → Frame 2
- Page 3 → Frame 7

For a logical address of **10,000**, the address translation works as follows:
1. **Page Number:** 10000 / 4096 = 2 (Page 2)
2. **Offset:** 10000 % 4096 = 1808
3. **Frame Number:** From the page table, we know that Page 2 is in Frame 2.
4. **Physical Address:** Frame 2 + Offset = 8192 + 1808 = **10,000** in physical memory.

---

### **Advantages of Paging:**
1. **No External Fragmentation:** Since the process is divided into fixed-size pages, there are no unused memory blocks scattered across memory.
2. **Efficient Use of Memory:** Processes can be loaded wherever there are free frames, maximizing memory utilization.

---

### **Disadvantages of Paging:**
1. **Internal Fragmentation:** The last page of a process might not fully use a frame, leading to some wasted space within that frame.
2. **Overhead:** Maintaining page tables and translating addresses adds overhead to the system, especially in large programs.

---

### **Summary:**
- **Non-contiguous memory allocation** allows processes to be scattered throughout physical memory, which is implemented through **paging**.
- In **paging**, logical addresses are divided into **pages**, and physical memory is divided into **frames**. The **page table** keeps track of which pages map to which frames, allowing the OS to translate logical addresses to physical addresses.
- While paging eliminates external fragmentation and improves memory utilization, it introduces internal fragmentation and adds the overhead of address translation.